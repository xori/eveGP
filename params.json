{"name":"eveGP","tagline":"A genetic programming library written in Java to simplify the creation of experiments.","body":"# eveGP\r\nThe evolutionary library _with grammar_ created for 4V82 and now used for everything. It has been created by Evan Verworn (4582938) `<ev09qz@brocku.ca>` for the purpose of creating experiments quickly.\r\n\r\n## How to install\r\nLocated in the `dist` folder will be a file called `eveGP.jar`. This is the entire library that must be included in your java CLASSPATH for your import statements to work.\r\n\r\nThat's it.\r\n\r\n## How to use\r\nThis is more of a longer topic but can be broken into smaller ones.\r\n\r\n* [Structure](#structure)\r\n* [Parameters](#parameters)\r\n* [Problem/Function Creation](#problem)\r\n* [Executing](#execution)\r\n\r\nExplicit [examples](#examples) will be given at the end of this document. You can totally just learn from those.\r\n\r\n<a id=\"structure\"></a>\r\n### Structure \r\nThe structure of a genetic programming problem is pretty simple, there are 3 primary things that will need to be in every project.\r\n\r\n<a id=\"problem\"></a>\r\n#### your **Problem**\r\n\r\nYour definition of your fitness function and possibily your testing functions if you have any. _(For testing data not trained on)_ This is a java class extending the `eveGP.GPproblem`, to learn more about what this entails you can scroll down to where we cover the [expected overriden functions](#GPproblem). Note that this will have to be in a package that you define and that this package must also be in your java CLASSPATH as eveGP will try to dynamically load it.\r\n\r\n#### your **Functions**\r\n\r\nVery minimal java classes extending the [GPfunction](#GPfunction) class with most likely a single function in them. These can range from as simple as addition to as complex as forier transforms. _(There are also built in functions for the simple cases. Add, Subtract, Multiply, etc. These are in the package `eveGP.func.*`)_ Your GP functions must also be in a package referenced in your java CLASSPATH.\r\n\r\n<a id=\"parameters\"></a>\r\n#### your **Parameters**\r\n\r\nThis is a text file named whatever you want, the standard to is end it with a '`.param`'. These parameters are where you can set global parameters, some of them will be required. You can also make up your custom parameters here then get them in your defined problems/functions with the `Parameter.get(\"<name>\")` function.\r\n\r\nThe parameters follow a syntax style of,\r\n\r\n\tNAME = VALUE\r\nwhere the `'='` is optional, and can also be replaced with either whitespace or the `':'` symbol. Or both `':='`\r\n\r\nYou must also declare your functions and how the GP can perform crossover/mutation with them. Your functions can be declared in your parameter file with the following syntax.\r\n\r\n\tfunction MY.PACKAGE.CLASS ({TYPE}) : TYPE\r\nwhere that is the manditory string 'function' followed by the java class URI of the defined function (this being in your java CLASSPATH). Followed by a list of virtual types that your function recieves, followed lastly by a return virtual type. For example.\r\n\r\n\tfunction net.verworn.GreaterThan (INT,INT) : BOOL\r\nIt should be noted that `'INT'` and `'BOOL'` do not map to actual java classes but are instead more a way of differentiating generic types. So when the crossover function is being applied it **does not** do this,\r\n\r\n\tGreaterThan(GreaterThan(5,2),3)\r\nWhich is of course incorrect because how can you compare a boolean to an integer in terms of which is greater.\r\n\r\nIf however you **do** want your function to _also_ accept `BOOL`s and `INT`s you can declare it twice,\r\n\r\n\tfunction net.verworn.GreaterThan (INT,INT) : BOOL\r\n\tfunction net.verworn.GreaterThan (BOOL,BOOL) : BOOL\r\nthen decide how it should handle these cases within the class `net.verworn.GreaterThan`. This declaration would accept **either** `BOOL`s OR `INT`s but not a mix of either. To make a function accept all virtual types you can denote it with a `'*'`.\r\n\r\n### System Parameters\r\nThe following parameters are optional (with the exception of \"`problem`\") their default values will be listed below.\r\n\r\n\tgenerations = 50\r\n\tpopulation  = 100\r\n\tseed\t\t= <random generated integer number at startup>\r\n\tmutation\t= 0.1\r\n\tcrossover\t= 0.9\r\n\telitism\t\t= 0\r\nThese are fairly standard parameters, just know that `mutation` and `crossover` should equal 1.0, `elitism` takes either a `0` or `1` and that there exists a global parameter called `generation` which defines the **current** generation when evaluating.\r\n\r\n\ttourney\t\t= 3\r\nRepresents how big the tournement size will be when selecting the top individuals.\r\n\r\n\tthreads\t\t= 1\r\nThis is a multi-threaded enabled library so you can have as many threads as you wish.\r\n\r\n\tproblem\t\t= my.package.Class\r\nThis is the only **manditory** parameter **not set** for you. This must be the java URI for your defined [problem](#problem) that is in your java CLASSPATH\r\n\r\n\troot.result = *\r\nBecause this library supports grammars you can define what you want your final virtual type to be. In the default case it is set to the wildcard, but you can make it whatever you wish.\r\n\r\n\tstats\t\t= \"stats\"\r\nThis is filename of the default stats file relative to the start location of the experiment. When you override the default `stat()` function in [GPproblem](#GPproblem) this is no longer used (unless you call `super.stat()`). \r\n\r\nThat's it. Remember you can define your own custom global variables by using the [previously defined syntax](#parameters).\r\n\r\n### Accessing Parameters in Java\r\n\r\nThe above was more of the syntax of **defining** global parameters, this section will be how to **use** them, and it all starts with\r\n\r\n\timport eveGP.internal.Parameter;\r\nThis class then has a few static functions which we will go into detail. Just know that these are for GLOBAL parameters and not [local (input) parameters](#localParameters).\r\n\r\n<a id=\"Parameter.set\"></a>\r\n##### `void Parameter.set(String key, Object value)`\r\nThis sets a global parameter with the index of `key` to the value of `value`. Note that it doesn't care about the type of the value and that this operation **is** multi-thread safe.\r\n\r\n<a id=\"Parameter.get\"></a>\r\n##### `Object Parameter.get(String key)`\r\nThis returns an uncasted object reference. This object is dependant on the `key` you send in, that is set with the [`set`](#Parameter.set) function.\r\n\r\n##### `float Parameter.getF(String key)`\r\nThis returns an unboxed Float primitive. This works in the same way as the [`get`](#Parameter.get) function but will attempt to cast it to a _'float'_. If it fails, it will print to the `stderr` and return a `null` object.\r\n\r\n##### `int Parameter.getI(String key)`\r\nThis returns an unboxed Integer primitive. This works in the same way as the [`get`](#Parameter.get) function but will attempt to cast it to a _'int'_. If it fails, it will print to the `stderr` and return a `null` object.\r\n\r\n##### `String Parameter.getS(String key)`\r\nThis returns a String object. This works in the same way as the [`get`](#Parameter.get) function but will attempt to cast it to a _'String'_. If it fails, it will print to the `stderr` and return a `null` object.\r\n\r\n##### `boolean Parameter.exists(String key)`\r\nReturns true only if there exists a link for an index named `key`.\r\n\r\n### Local Variables\r\nWhen this GP library creates your parse trees you will need to set variables relivent for a particular individual. For example, in the case of\r\n\r\n\t+ ( X, Y)\r\nWhat is `X` and `Y`? You will most likely be testing this data on many rows of data and `X` and `Y` will be changing with each row. You can't hardcode it. In these cases you can set these variables within the current tree by the following statement.\r\n\r\n\tsetVariable(\"X\", i);\r\n\tsetVariable(\"Y\", j);\r\nWhere `i` and `j` are some object (possibly 5 or 10 or \"cookie\"). These variables can then be retrieved by your later defined terminal functions with the statement.\r\n\r\n\tint x = (int) getVariable(\"X\");\r\nCasting these variables can get very annoying fast so a few helper functions were created to do just that.\r\n\r\n\tgetIntVariable(\"X\");\r\n\tgetStringVariable(\"X\");\r\n\tgetFloatVariable(\"X\");\r\nAll of these will attempt to cast the stored variable to the desired type, if it fails it will yell an error message and return null.\r\n\r\n<a id=\"problem\"></a><a id=\"GPproblem\"></a>\r\n### Creating Problems (GPproblem)\r\nA problem in eveGP is a java class in a package defined in your java CLASSPATH that extends the `eveGP.GPproblem` class. This class has a few functions that can be overriden.\r\n\r\n##### `abstract float evaluate ( Tree tree )`\r\nThis function is the only **required** function to be overriden. The purpose of this function is to return the evaluated fitness result, or the 'score' for the individual (_`tree`_). The individuals result can be retreived by running `tree.evaluate()`. The standard is to return a zero if that individual is a optimal solution.\r\n\r\n##### `void stats (int generation, Tree ... trees)`\r\nThis function is an optional one that is run at the end of each generation. This is where you would process the generations results and maybe run your testing data if you had any. The array `trees` have been scored and their scores can be accessed via the field `trees[i].score`.\r\n\r\nIt should also be noted that if you want the default stats creation you should run `super.stats(generation, trees)` to output to the `stats.txt` file.\r\n\r\n##### `void best (Tree t)`\r\nThere is also one more function, this function is run _once_ at the end of the experiment. It is passed the individual with the best score for you to run the individual on maybe more data, data that you wouldn't want to run on all of the individuals. This can sometimes give you a better representation of _how good_ your generated solution is.\r\n\r\n<a id=\"GPfunction\"></a>\r\n### Creating Functions (GPfunction)\r\nFunctions can be like 'add' or 'subtract' or 'sine'. They can also be like 'move left', 'turn right' or 'attack'. It's really up to your creativity but the basis is that it must take **in** parameters and **return** a result.\r\n\r\nThe process of making a function starts by extending the `eveGP.GPfunction` class. This class has really only 2 functions that must be overriden.\r\n\r\n##### `abstract float result (Tree ... children)`\r\nThis function takes in an array of other functions. The result of one of these trees can be retrieved using `children[i].evaluate()`. This function can be very simple, below is an example of a multiply function.\r\n\r\n\t@Override\r\n\tpublic float result(Tree ... children) {\r\n\t\treturn children[0].evaluate() * children[1].evaluate();\r\n\t}\r\nCrazy I know. Here is another example, of a `X` terminal function getting the local variable.\r\n\r\n\t@Override\r\n\tpublic float result(Tree ... children) {\r\n\t\treturn getFloatVariable(\"X\");\r\n\t}\r\nThey can of course be more complicated but there isn't a rule saying that they have to be.\r\n\r\n##### `String toString(Tree ... children)`\r\nWhen eveGP tries to output this tree it needs to know how to serialize this current fuction. Best just to see what I mean by example.\r\n\r\n    public String toString (Tree ... children){\r\n        return \"(PLUS \"+children[0].toString()+\" \"+children[1].toString()+\")\";\r\n    }\r\nThis is an example of a `toString` method for an addition `GPfunction`. Calling `toString()` on a tree will trigger it to recurse to serialize its' children.\r\n\r\nWhile this function is not *manditory* it is obviously highly recommended. After all if you don't put this in, you won't be able to do analysis on your generated function because you won't know what it is.\r\n\r\n\t(NOT DEFINED (NOT DEFINED (NOT DEFINED NOT DEFINED NOT DEFINED)))\r\nWhat an amazing function that it.\r\n\r\n<a id=\"execution\"></a>\r\n### Running Your Experiment\r\nSo now you have,\r\n\r\n1. A [Problem](#GPproblem)\r\n2. A list of [functions](#GPfunction)\r\n3. A [Parameter](#parameters) file (with your functions declared in them)\r\n\r\nYou can then run your experiment with,\r\n\r\n\tjava -jar eveGP.jar /some/dir/yourParameters.params\r\n\t\tor\r\n\tjava eveGP.Evolve /some/dir/yourParameters.params\r\n\r\nYou can also set parameters on the command line. So for example if you were running your experiement 50 times you could (in a linux environment)\r\n\r\n\t#!/bin/bash\r\n\tfor i in {0..50}\r\n\tdo\r\n\t\tjava -jar eveGP.jar myParams.params seed=$i\r\n\tdone\r\n\r\nYou can append as many parameters as you want onto the end of the line, but make sure that there are **NO** whitespace between the name and the value.\r\n\r\n\tseed = 5 // INCORRECT\r\n\tseed=5   // CORRECT!\r\n\r\n<a id=\"examples\"></a>\r\n## Learn by Example\r\n\r\n#### An example parameter file.\r\n\tgenerations = 10\r\n\tpopulation  = 50\r\n\t\r\n\tmutation    = 0.1\r\n\tcrossover   = 0.9\r\n\t\r\n\tseed\t    = 2\r\n\ttourney     = 5\r\n\tthreads     = 6\r\n\t\r\n\tproblem\t    = example.Regression\r\n\t\r\n\tfunction eveGP.func.Add      (Float, Float) : Float\r\n\tfunction eveGP.func.Multiply (Float, Float) : Float\r\n\tfunction eveGP.func.X        ()             : Float\r\n\tfunction eveGP.func.ERC      ()             : Float\r\n\r\n_Note the function `eveGP.func.ERC` this is a ephemeral random constant function that has been made for you. I would suggest tring to modify this to your needs rather than creating something yourself._\r\n\r\n#### An example simple regression GPproblem\r\n\tpackage example;\r\n\t\r\n\timport eveGP.internal.Tree;\r\n\timport static java.lang.Math.*;\r\n\t\r\n\tpublic class Regression extends eveGP.GPproblem {\r\n\t\r\n\t    private float myFunction (int X) {\r\n\t\t\treturn (float) (pow(X,3) + pow(X,2) + X);\r\n\t    }\r\n\t    \r\n\t    @Override\r\n\t    public float evaluate(Tree tree) {\r\n\t\t\tfloat sum = 0;\r\n\t\t\tfor (int x = 0; x < 100; x++) {\r\n\t\t\t    setVariable(\"X\", x);\r\n\t\t\t    sum += abs(tree.evaluate() - myFunction(x));\r\n\t\t\t}\r\n\t\t\treturn sum;\r\n\t    }\r\n\t}\r\n\r\n#### An example of an ephemeral random constant GPfunction\r\nThis is one of the more complicated GPfunctions that you could implement. I would just recommend coping this if you want to implement a ERC.\r\n\r\n\tpackage eveGP.func;\r\n\t\r\n\timport eveGP.internal.Tree;\r\n\timport static eveGP.internal.Parameter.get;\r\n\timport java.util.Random;\r\n\r\n\tpublic class ERC extends eveGP.GPfunction {\r\n\t\r\n\t    private float variable = Float.NaN;\r\n\t    \r\n\t    public void init () {\r\n\t        Random g = (Random) get(\"rGenerator\");\r\n\t        // rGenerator is the system random generator.\r\n\t        this.variable = (g.nextInt(2) - 1) + g.nextFloat();\r\n\t    }\r\n\t    \r\n\t    @Override\r\n\t    public float result(Tree ... children) {\r\n\t        if (Float.isNaN(variable)) {\r\n\t            init();\r\n\t        }\r\n\t        return this.variable;\r\n\t    }\r\n\t    \r\n\t    @Override\r\n\t    public Object clone() {\r\n\t        ERC node = null;\r\n\t        try {\r\n\t            node = (ERC) super.clone();\r\n\t            if (Float.isNaN(variable));\r\n\t                // Don't init on ourselves because there is one object at the\r\n\t                // begining that we clone into every other ERC. \r\n\t                node.init();\r\n\t        } catch (Exception e) { \r\n\t            System.err.println(\"Failure.\");\r\n\t        }\r\n\t        return node;\r\n\t    }\r\n\t    \r\n\t    @Override\r\n\t    public String toString (Tree ... t) {\r\n\t        return String.valueOf(variable);\r\n\t    }\r\n\t    \r\n\t}\r\n\r\n#### A move conventional example of a GPfunction\r\nThis example is a GreaterThan function.\r\n\r\n\tpackage eveGP.func;\r\n\t\r\n\timport eveGP.internal.Tree;\r\n\t\r\n\tpublic class GreaterThan extends eveGP.GPfunction {\r\n\t\r\n\t    @Override\r\n\t    public float result(Tree... children) {\r\n\t        float d = children[0].evaluate() - children[1].evaluate();\r\n\t        return (d > 0) ? 1 : 0;\r\n\t    }\r\n\t    \r\n\t    public String toString (Tree ... children) {\r\n\t        return \"( > \"+ children[0].toString() +\r\n\t                \" \" + children[1].toString() + \" )\";\r\n\t    }\r\n\t}\r\n\t\r\n## The MIT License (MIT)\r\nCopyright (c) 2013 Evan Verworn\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}